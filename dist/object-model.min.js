(function(b){"use strict";function c(M,N){return N instanceof M}function g(M){return"function"==typeof M}function h(M){return"object"==typeof M}function j(M){return M&&h(M)&&Object.getPrototypeOf(M)===Object.prototype}function k(M){return{}.toString.call(M).match(/\s([a-zA-Z]+)/)[1]}function l(M,N={},O,P){for(let Q in N)if(P||N.hasOwnProperty(Q))if(O&&j(N[Q])){const R={};l(R,M[Q],O),l(R,N[Q],O),M[Q]=R}else M[Q]=N[Q]}function m(M,N,O,P=!1){I(M,N,{value:O,enumerable:P,writable:!0,configurable:!0})}function n(M,N){Object.setPrototypeOf(M,N.prototype),m(M,"constructor",N)}function q(M,N){M.prototype=Object.create(N),M.prototype.constructor=M}function r(M,N=[]){if(15<N.length||N.includes(M))return"...";if(null===M||void 0===M)return M+"";if("string"==typeof M)return`"${M}"`;if(c(w,M))return M.toString(N);if(N=[M].concat(N),g(M))return M.name||M.toString(N);if(c(Array,M))return`[${M.map((O)=>r(O,N)).join(", ")}]`;if(M.toString!==Object.prototype.toString)return M.toString();if(M&&h(M)){const O=Object.keys(M),P="\t".repeat(N.length);return`{${O.map((Q)=>`\n${P+Q}: ${r(M[Q],N)}`).join(",")} ${O.length?`\n${P.slice(1)}`:""}}`}return M+""}function s(M,N,O,P,Q,R=!1){const S=Q.indexOf(N);if(-1!==S&&-1!==Q.indexOf(N,S+1))return M;if(R&&(M=v(M,N)),c(w,N))N._validate(M,O,P,Q.concat(N));else if(j(N))Object.keys(N).forEach((T)=>{const U=null==M?void 0:M[T];s(U,N[T],O?O+"."+T:T,P,Q)});else{const T=y(N);if(T.some((U)=>t(M,U,O,Q)))return M;P.push({expected:N,received:M,path:O})}return M}function t(M,N,O,P){if(null==M)return M===N;if(j(N)||c(w,N)){const Q=[];return s(M,N,O,Q,P),!Q.length}return c(RegExp,N)?N.test(M):N===Number||N===Date?M.constructor===N&&!isNaN(M):M===N||g(N)&&c(N,M)||M.constructor===N}function u(M,N,O,P=N.errorStack){for(let Q of N.assertions){let R;try{R=Q.call(N,M)}catch(S){R=S}if(!0!==R){const S=g(Q.description)?Q.description:(T,U)=>`assertion "${Q.description}" returned ${r(T)} for value ${r(U)}`;P.push({message:S.call(N,R,M),expected:Q,received:M,path:O})}}}function v(M,N=[]){if(!M||j(N)||c(w,M.constructor))return M;const O=y(N),P=[];for(let Q of O)c(w,Q)&&Q.test(M)&&P.push(Q);return 1===P.length?P[0](M):(1<P.length&&console.warn(`Ambiguous model for value ${r(M)}, could be ${P.join(" or ")}`),M)}function w(){const N=function(O=N.default){return N.validate(O),O};return x(N,arguments,w),N}function x(M,N,O){if(0===N.length)throw new Error("Model definition is required");n(M,O),M.definition=N[0],M.assertions=M.assertions.slice(),m(M,"errorStack",[])}function y(M){if(!j(M)){if(!c(Array,M))return[M];if(1===M.length)return[...M,void 0,null]}else for(let N of Object.keys(M))M[N]=y(M[N]);return M}function z(){const N=function(O=N.default){return c(N,this)?c(N,O)?O:(l(this,O,!0),N.validate(this),A(N,this,N.definition)):new N(O)};return q(N,Object.prototype),x(N,arguments,z),N}function A(M,N,O,P){return j(O)?new Proxy(N||{},{get(Q,R){const S=P?P+"."+R:R,T=O[R];return R in O&&M.conventionForPrivate(R)?(M.errorStack.push({message:`cannot access to private property ${S}`}),void M.unstackErrors()):(Q[R]&&Q.hasOwnProperty(R)&&!j(T)&&!c(w,Q[R].constructor)&&(Q[R]=v(Q[R],T)),g(Q[R])&&Q[R].bind?Q[R].bind(Q):A(M,Q[R],T,S))},set(Q,R,S){return B(M,O,P,Q,R,(T)=>{Reflect.set(Q,R,A(M,S,O[R],T))})},deleteProperty(Q,R){return B(M,O,P,Q,R,()=>Reflect.deleteProperty(Q,R))},defineProperty(Q,R,S){return B(M,O,P,Q,R,()=>Reflect.defineProperty(Q,R,S))},has(Q,R){return Reflect.has(Q,R)&&Reflect.has(O,R)&&!M.conventionForPrivate(R)},ownKeys(Q){return Reflect.ownKeys(Q).filter((R)=>Reflect.has(O,R)&&!M.conventionForPrivate(R))},getOwnPropertyDescriptor(Q,R){return M.conventionForPrivate(R)?void 0:Reflect.getOwnPropertyDescriptor(Q,R)},getPrototypeOf(){return M.prototype}}):v(N,O)}function B(M,N,O,P,Q,R){const S=O?O+"."+Q:Q,T=M.conventionForPrivate(Q),U=M.conventionForConstant(Q),V=P.hasOwnProperty(Q),W=V&&Object.getOwnPropertyDescriptor(P,Q);return Q in N&&(T||U&&void 0!==P[Q])&&M.errorStack.push({message:`cannot modify ${T?"private":"constant"} ${Q}`}),N.hasOwnProperty(Q)?(R(S),s(P[Q],N[Q],S,M.errorStack,[]),u(P,M,S)):M.errorStack.push({message:`cannot find property ${S} in the model definition`}),!M.errorStack.length||(V?Object.defineProperty(P,Q,W):delete P[Q],M.unstackErrors(),!1)}function C(){const N=function(O=N.default){return c(N,this)?(N.validate(O),new Proxy(O,{get(P,Q){return J.includes(Q)?D(P,Q,N):P[Q]},set(P,Q,R){return E(P,Q,R,N),!0},getPrototypeOf(){return N.prototype}})):new N(O)};return q(N,Array.prototype),x(N,arguments,C),N}function D(M,N,O){return function(){const P=M.slice();Array.prototype[N].apply(P,arguments),O.validate(P);const Q=Array.prototype[N].apply(M,arguments);return M.forEach((R,S)=>M[S]=v(R,O.definition)),Q}}function E(M,N,O,P){let Q=`Array[${N}]`;parseInt(N)===+N&&0<=N&&(O=s(O,P.definition,Q,P.errorStack,[],!0));const R=M.slice();R[N]=O,u(R,P,Q),P.unstackErrors(),M[N]=O}function F(){const M=function(O=M.default){return new Proxy(O,{getPrototypeOf:()=>M.prototype,apply(P,Q,R){const S=M.definition;R=Object.assign([],S.defaults,R),S.arguments.forEach((U,V)=>{R[V]=s(R[V],U,`arguments[${V}]`,M.errorStack,[],!0)}),u(R,M,"arguments");let T;return M.errorStack.length||(T=Reflect.apply(P,Q,R),"return"in S&&(T=s(T,S.return,"return value",M.errorStack,[],!0))),M.unstackErrors(),T}})};q(M,Function.prototype);const N={arguments:[...arguments]};return x(M,[N],F),M}function G(){const N=function(O){const P=new Map(O);N.validate(P);for(let Q of K)P[Q]=function(){const R=new Map(P);return Map.prototype[Q].apply(R,arguments),N.validate(R),Map.prototype[Q].apply(P,arguments)};return n(P,N),P};return q(N,Map.prototype),x(N,arguments,G),N}function H(){const N=function(O){const P=new Set(O);N.validate(P);for(let Q of L)P[Q]=function(){const R=new Set(P);return Set.prototype[Q].apply(R,arguments),N.validate(R),Set.prototype[Q].apply(P,arguments)};return n(P,N),P};return q(N,Set.prototype),x(N,arguments,H),N}const I=Object.defineProperty;Object.assign(w.prototype,{toString(M){return y(this.definition).map((N)=>r(N,M)).join(" or ")},assertions:[],validate(M,N){this._validate(M,null,this.errorStack,[]),this.unstackErrors(N)},test(M){let N,O=this.errorCollector;return this.errorCollector=()=>{N=!0},this(M),this.errorCollector=O,!N},extend(){const M=[...arguments],N=M.reduce((Q,R)=>Q.concat(y(R)),y(this.definition)).filter((Q,R,S)=>S.indexOf(Q)===R);let O=[...this.assertions];M.forEach((Q)=>{c(w,Q)&&(O=O.concat(Q.assertions))});const P=new this.constructor(N);return q(P,this.prototype),P.assertions=O,P.errorCollector=this.errorCollector,P},assert(M,N=r(M)){return m(M,"description",N),this.assertions=this.assertions.concat(M),this},defaultTo(M){return this.default=M,this},errorCollector(M){let N=new TypeError(M.map((O)=>O.message).join("\n"));throw N.stack=N.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),N},_validate(M,N,O,P){s(M,this.definition,N,O,P),u(M,this,N,O)},unstackErrors(M){if(this.errorStack.length){M||(M=this.errorCollector);const N=this.errorStack.map((O)=>{if(!O.message){const P=c(Array,O.expected)?O.expected:[O.expected];O.message="expecting "+(O.path?O.path+" to be ":"")+P.map((Q)=>r(Q)).join(" or ")+", got "+(null==O.received?"":k(O.received)+" ")+r(O.received)}return O});this.errorStack=[],M.call(this,N)}}}),w.prototype.conventionForConstant=(M)=>M.toUpperCase()===M,w.prototype.conventionForPrivate=(M)=>"_"===M[0],q(z,w.prototype),Object.assign(z.prototype,{defaults(M){return Object.assign(this.prototype,M),this},toString(M){return r(this.definition,M)},extend(){const M={},N={},O=[...arguments];Object.assign(M,this.definition),l(N,this.prototype,!1,!0),O.forEach((R)=>{c(w,R)&&l(M,R.definition,!0),g(R)&&l(N,R.prototype,!0,!0),h(R)&&l(M,R,!0,!0)}),delete N.constructor;let P=[...this.assertions];O.forEach((R)=>{c(w,R)&&(P=P.concat(R.assertions))});const Q=new this.constructor(M);return q(Q,this.prototype),Object.assign(Q.prototype,N),Q.assertions=P,Q.errorCollector=this.errorCollector,Q},_validate(M,N,O,P){h(M)?s(M,this.definition,N,O,P):O.push({expected:this,received:M,path:N}),u(M,this,N,O)}});const J=["pop","push","reverse","shift","sort","splice","unshift"];q(C,w.prototype),Object.assign(C.prototype,{toString(M){return"Array of "+r(this.definition,M)},_validate(M,N,O,P){c(Array,M)?M.forEach((Q,R)=>{M[R]=s(Q,this.definition,`${N||"Array"}[${R}]`,O,P,!0)}):O.push({expected:this,received:M,path:N}),u(M,this,N,O)}}),q(F,w.prototype),Object.assign(F.prototype,{toString(M){let N="Function("+this.definition.arguments.map((O)=>r(O,M)).join(",")+")";return"return"in this.definition&&(N+=" => "+r(this.definition.return)),N},return(M){return this.definition.return=M,this},defaults(){return this.definition.defaults=[...arguments],this},_validate(M,N,O){g(M)||O.push({expected:"Function",received:M,path:N})}}),F.prototype.assert(function(M){return!(M.length>this.definition.arguments.length)||M},function(M){return`expecting ${this.definition.arguments.length} arguments for ${r(this)}, got ${M.length}`});const K=["set","delete","clear"];q(G,w.prototype),Object.assign(G.prototype,{toString(M){return"Map of "+r(this.definition,M)},_validate(M,N,O,P){if(M instanceof Map)for(let[Q,R]of M)s(R,this.definition,`${N||"Map"}[${Q}]`,O,P);else O.push({expected:this,received:M,path:N});u(M,this,O)}});const L=["add","delete","clear"];q(H,w.prototype),Object.assign(H.prototype,{toString(M){return"Set of "+r(this.definition,M)},_validate(M,N,O,P){if(M instanceof Set)for(let Q of M.values())s(Q,this.definition,N||"Set",O,P);else O.push({expected:this,received:M,path:N});u(M,this,O)}}),b.BasicModel=w,b.ObjectModel=z,b.ArrayModel=C,b.FunctionModel=F,b.MapModel=G,b.SetModel=H})(this.ObjectModelBundle=this.ObjectModelBundle||{});
