(function(b){"use strict";function c(V,W){return W instanceof V}function g(V){return"function"==typeof V}function h(V){return"object"==typeof V}function j(V){return V&&h(V)&&Object.getPrototypeOf(V)===Object.prototype}function k(V){return{}.toString.call(V).match(/\s([a-zA-Z]+)/)[1]}function l(V,W={},X,Y){for(let Z in W)if(Y||W.hasOwnProperty(Z))if(X&&j(W[Z])){const $={};l($,V[Z],X),l($,W[Z],X),V[Z]=$}else V[Z]=W[Z]}function m(V,W,X,Y=!1){O(V,W,{value:X,enumerable:Y,writable:!0,configurable:!0})}function n(V,W){Object.setPrototypeOf(V,W.prototype),m(V,"constructor",W)}function q(V,W){V.prototype=Object.create(W),V.prototype.constructor=V}function r(V,W=[]){if(15<W.length||W.includes(V))return"...";if(null===V||void 0===V)return V+"";if("string"==typeof V)return`"${V}"`;if(c(C,V))return V.toString(W);if(W=[V].concat(W),g(V))return V.name||V.toString(W);if(c(Array,V))return`[${V.map((X)=>r(X,W)).join(", ")}]`;if(V.toString!==Object.prototype.toString)return V.toString();if(V&&h(V)){const X=Object.keys(V),Y="\t".repeat(W.length);return`{${X.map((Z)=>`\n${Y+Z}: ${r(V[Z],W)}`).join(",")} ${X.length?`\n${Y.slice(1)}`:""}}`}return V+""}function s(V){if(!j(V)){if(!c(Array,V))return[V];if(1===V.length)return[...V,void 0,null]}else for(let W of Object.keys(V))V[W]=s(V[W]);return V}function t(V,W,X,Y,Z,$=!1){const _=Z.indexOf(W);if(-1!==_&&-1!==Z.indexOf(W,_+1))return V;if($&&(V=w(V,W)),c(C,W))W._validate(V,X,Y,Z.concat(W));else if(j(W))Object.keys(W).forEach((aa)=>{const ba=null==V?void 0:V[aa];t(ba,W[aa],X?X+"."+aa:aa,Y,Z)});else{const aa=s(W);if(aa.some((ba)=>u(V,ba,X,Z)))return V;Y.push({expected:W,received:V,path:X})}return V}function u(V,W,X,Y){if(null==V)return V===W;if(j(W)||c(C,W)){const Z=[];return t(V,W,X,Z,Y),!Z.length}return c(RegExp,W)?W.test(V):W===Number||W===Date?V.constructor===W&&!isNaN(V):V===W||g(W)&&c(W,V)||V.constructor===W}function v(V,W,X,Y=W.errorStack){for(let Z of W.assertions){let $;try{$=Z.call(W,V)}catch(_){$=_}if(!0!==$){const _=g(Z.description)?Z.description:(aa,ba)=>`assertion "${Z.description}" returned ${r(aa)} for value ${r(ba)}`;Y.push({message:_.call(W,$,V),expected:Z,received:V,path:X})}}}function w(V,W=[]){if(!V||j(W)||c(C,V.constructor))return V;const X=s(W),Y=[];for(let Z of X)c(C,Z)&&Z.test(V)&&Y.push(Z);if(1===Y.length){const Z=Y[0];return c(C,Z)?Z(V):new Z(V)}return 1<Y.length&&console.warn(`Ambiguous model for value ${r(V)}, could be ${Y.join(" or ")}`),V}function y(){const W=function(X=W.default){return W.validate(X),X};return D(W,arguments,y),W}function z(){const W=function(X=W.default){return c(W,this)?c(W,X)?X:(l(this,X,!0),W.hasOwnProperty("constructor")&&W.constructor.call(this,X),W.validate(this),A(W,this,W.definition)):new W(X)};return q(W,Object.prototype),D(W,arguments,z),W}function A(V,W,X,Y){return j(X)?new Proxy(W||{},{getPrototypeOf(){return X===V.definition?V.prototype:Object.prototype},get(Z,$){const _=Y?Y+"."+$:$,aa=X[$];return $ in X&&V.conventionForPrivate($)?(V.errorStack.push({message:`cannot access to private property ${_}`}),void V.unstackErrors()):(Z[$]&&Z.hasOwnProperty($)&&!j(aa)&&!c(C,Z[$].constructor)&&(Z[$]=w(Z[$],aa)),g(Z[$])&&Z[$].bind?Z[$].bind(Z):A(V,Z[$],aa,_))},set(Z,$,_){return B(V,X,Y,Z,$,(aa)=>{Reflect.set(Z,$,A(V,_,X[$],aa))})},deleteProperty(Z,$){return B(V,X,Y,Z,$,()=>Reflect.deleteProperty(Z,$))},defineProperty(Z,$,_){return B(V,X,Y,Z,$,()=>Reflect.defineProperty(Z,$,_))},has(Z,$){return Reflect.has(Z,$)&&Reflect.has(X,$)&&!V.conventionForPrivate($)},ownKeys(){return Reflect.ownKeys(X).filter((Z)=>!V.conventionForPrivate(Z))},getOwnPropertyDescriptor(Z,$){let _;return V.conventionForPrivate($)||(_=Object.getOwnPropertyDescriptor(X,$),void 0!==_&&(_.value=Z[$])),_}}):w(W,X)}function B(V,W,X,Y,Z,$){const _=X?X+"."+Z:Z,aa=V.conventionForPrivate(Z),ba=V.conventionForConstant(Z),ca=Y.hasOwnProperty(Z),da=ca&&Object.getOwnPropertyDescriptor(Y,Z);return Z in W&&(aa||ba&&void 0!==Y[Z])&&V.errorStack.push({message:`cannot modify ${aa?"private":"constant"} ${Z}`}),W.hasOwnProperty(Z)?($(_),t(Y[Z],W[Z],_,V.errorStack,[]),v(Y,V,_)):V.errorStack.push({message:`cannot find property ${_} in the model definition`}),!V.errorStack.length||(ca?Object.defineProperty(Y,Z,da):delete Y[Z],V.unstackErrors(),!1)}function C(V){return j(V)?z(V):y(V)}function D(V,W,X){if(0===W.length)throw new Error("Model definition is required");n(V,X),V.definition=W[0],V.assertions=V.assertions.slice(),m(V,"errorStack",[]),delete V.name}function E(){const W=function(X=W.default){return c(W,this)?(W.validate(X),new Proxy(X,{getPrototypeOf:()=>W.prototype,get(Y,Z){return P.includes(Z)?F(Y,Z,W):Y[Z]},set(Y,Z,$){return G(Y,Z,$,W)},deleteProperty(Y,Z){return!(Z in Y)||G(Y,Z,void 0,W)}})):new W(X)};return q(W,Array.prototype),D(W,arguments,E),W}function F(V,W,X){return function(){const Y=V.slice();Array.prototype[W].apply(Y,arguments),X.validate(Y);const Z=Array.prototype[W].apply(V,arguments);return V.forEach(($,_)=>V[_]=w($,X.definition)),Z}}function G(V,W,X,Y){let Z=`Array[${W}]`;parseInt(W)===+W&&0<=W&&(X=t(X,Y.definition,Z,Y.errorStack,[],!0));const $=V.slice();$[W]=X,v($,Y,Z);const _=!Y.unstackErrors();return _&&(V[W]=X),_}function H(){const V=function(X=V.default){return new Proxy(X,{getPrototypeOf:()=>V.prototype,apply(Y,Z,$){const _=V.definition;_.arguments.forEach((ba,ca)=>{$[ca]=t($[ca],ba,`arguments[${ca}]`,V.errorStack,[],!0)}),v($,V,"arguments");let aa;return V.errorStack.length||(aa=Reflect.apply(Y,Z,$),"return"in _&&(aa=t(aa,_.return,"return value",V.errorStack,[],!0))),V.unstackErrors(),aa}})};q(V,Function.prototype);const W={arguments:[...arguments]};return D(V,[W],H),V}function I(){const W=function(X){const Y=new Map(X);W.validate(Y);for(let Z of Q)Y[Z]=function(){const $=new Map(Y);return Map.prototype[Z].apply($,arguments),W.validate($),Map.prototype[Z].apply(Y,arguments)};return n(Y,W),Y};return q(W,Map.prototype),D(W,arguments,I),W}function J(){const W=function(X){const Y=new Set(X);W.validate(Y);for(let Z of R)Y[Z]=function(){const $=new Set(Y);return Set.prototype[Z].apply($,arguments),W.validate($),Set.prototype[Z].apply(Y,arguments)};return n(Y,W),Y};return q(W,Set.prototype),D(W,arguments,J),W}function K(V){if(V===void 0||null===V)return null;const W=Object.getPrototypeOf(V);return W&&W.constructor&&c(C,W.constructor)?W.constructor:null}function L(V,W){if(null===V||V===void 0)return["span",{style:S.null},V+""];if("boolean"==typeof V)return["span",{style:S.boolean},V];if("number"==typeof V)return["span",{style:S.number},V];if("string"==typeof V)return["span",{style:S.string},`"${V}"`];if(c(Array,V)){let X=[];1===V.length&&V.push(void 0,null);for(let Y=0;Y<V.length;Y++)X.push(L(V[Y])),Y<V.length-1&&X.push(" or ");return["span",{},...X]}return j(V)?M(V,K(V),W):g(V)&&!c(C,V)?["span",{style:S.function},V.name||V.toString()]:V?["object",{object:V,config:W}]:null}function M(V,W,X){return["ol",{style:S.list},"{",...Object.keys(V).map((Y)=>{let Z=W&&W.conventionForPrivate(Y);return["li",{style:S.listItem},["span",{style:Z?S.private:S.property},Y],": ",L(V[Y],X)]}),"}"]}function N(V,W){return c(C,V)?["span",{style:S.model},V.name]:W.fromModel||j(V)||Array.isArray(V)?L(V):null}const O=Object.defineProperty;q(y,C.prototype),q(z,C.prototype),Object.assign(z.prototype,{defaults(V){return Object.assign(this.prototype,V),this},toString(V){return r(this.definition,V)},extend(){const V={},W={},X=[...arguments];Object.assign(V,this.definition),l(W,this.prototype,!1,!0),X.forEach(($)=>{c(C,$)&&l(V,$.definition,!0),g($)&&l(W,$.prototype,!0,!0),h($)&&l(V,$,!0,!0)}),delete W.constructor;let Y=[...this.assertions];X.forEach(($)=>{c(C,$)&&(Y=Y.concat($.assertions))});const Z=new this.constructor(V);return q(Z,this.prototype),Object.assign(Z.prototype,W),Z.assertions=Y,Z.errorCollector=this.errorCollector,Z},_validate(V,W,X,Y){h(V)?t(V,this.definition,W,X,Y):X.push({expected:this,received:V,path:W}),v(V,this,W,X)}}),Object.assign(C.prototype,{name:"Model",assertions:[],conventionForConstant:(V)=>V.toUpperCase()===V,conventionForPrivate:(V)=>"_"===V[0],toString(V){return s(this.definition).map((W)=>r(W,V)).join(" or ")},as(V){return m(this,"name",V),this},defaultTo(V){return this.default=V,this},_validate(V,W,X,Y){t(V,this.definition,W,X,Y),v(V,this,W,X)},validate(V,W){this._validate(V,null,this.errorStack,[]),this.unstackErrors(W)},test(V){let W,X=this.errorCollector;return this.errorCollector=()=>{W=!0},new this(V),this.errorCollector=X,!W},unstackErrors(V){if(this.errorStack.length){V||(V=this.errorCollector);const W=this.errorStack.map((X)=>{if(!X.message){const Y=c(Array,X.expected)?X.expected:[X.expected];X.message="expecting "+(X.path?X.path+" to be ":"")+Y.map((Z)=>r(Z)).join(" or ")+", got "+(null==X.received?"":k(X.received)+" ")+r(X.received)}return X});this.errorStack=[],V.call(this,W)}},errorCollector(V){let W=new TypeError(V.map((X)=>X.message).join("\n"));throw W.stack=W.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),W},extend(...V){let W=this.definition;0<V.length&&(W=V.reduce((Z,$)=>Z.concat($),Array.isArray(W)?W.slice():[W]).filter((Z,$,_)=>_.indexOf(Z)===$));let X=[...this.assertions];V.forEach((Z)=>{c(y,Z)&&(X=X.concat(Z.assertions))});const Y=new this.constructor(W);return q(Y,this.prototype),Y.assertions=X,Y.errorCollector=this.errorCollector,Y},assert(V,W=r(V)){return m(V,"description",W),this.assertions=this.assertions.concat(V),this}});const P=["pop","push","reverse","shift","sort","splice","unshift"];q(E,C.prototype),Object.assign(E.prototype,{toString(V){return"Array of "+r(this.definition,V)},_validate(V,W,X,Y){c(Array,V)?V.forEach((Z,$)=>{V[$]=t(Z,this.definition,`${W||"Array"}[${$}]`,X,Y,!0)}):X.push({expected:this,received:V,path:W}),v(V,this,W,X)}}),q(H,C.prototype),Object.assign(H.prototype,{toString(V){let W="Function("+this.definition.arguments.map((X)=>r(X,V)).join(",")+")";return"return"in this.definition&&(W+=" => "+r(this.definition.return)),W},return(V){return this.definition.return=V,this},_validate(V,W,X){g(V)||X.push({expected:"Function",received:V,path:W})}}),H.prototype.assert(function(V){return!(V.length>this.definition.arguments.length)||V},function(V){return`expecting ${this.definition.arguments.length} arguments for ${r(this)}, got ${V.length}`});const Q=["set","delete","clear"];q(I,C.prototype),Object.assign(I.prototype,{toString(V){return"Map of "+r(this.definition,V)},_validate(V,W,X,Y){if(V instanceof Map)for(let[Z,$]of V)t($,this.definition,`${W||"Map"}[${Z}]`,X,Y);else X.push({expected:this,received:V,path:W});v(V,this,X)}});const R=["add","delete","clear"];q(J,C.prototype),Object.assign(J.prototype,{toString(V){return"Set of "+r(this.definition,V)},_validate(V,W,X,Y){if(V instanceof Set)for(let Z of V.values())t(Z,this.definition,W||"Set",X,Y);else X.push({expected:this,received:V,path:W});v(V,this,X)}});const S={list:`list-style-type: none; padding: 0; margin: 0;`,listItem:`padding: 0 0 0 1em;`,model:`color: #43a047; font-style: italic`,function:`color: #4271ae`,string:`color: #C41A16`,number:`color: #1C00CF`,boolean:`color: #AA0D91`,property:`color: #881391`,private:`color: #B871BD`,null:`color: #808080`};"undefined"!=typeof window&&(window.devtoolsFormatters=(window.devtoolsFormatters||[]).concat({header:function(V,W={}){return W.fromModel||c(C,V)?N(V,W):null},hasBody:function(V){return c(C,V)},body:function(V){return L(V.definition,{fromModel:!0})}},{header:function(V,W={}){if(W.fromInstance&&j(V))return N(V,W);const X=K(V);return c(C,X)?["span",{style:S.model},V.constructor.name]:null},hasBody:function(V){return V&&c(z,K(V))},body:function(V){return M(V,K(V),{fromInstance:!0})}})),b.Model=C,b.BasicModel=y,b.ObjectModel=z,b.ArrayModel=E,b.FunctionModel=H,b.MapModel=I,b.SetModel=J})(this.window=this.window||{});
