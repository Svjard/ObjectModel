// ObjectModel v3.0.0 - http://objectmodel.js.org
(function(b){"use strict";function c(L,M){return M instanceof L}function g(L){return"function"==typeof L}function h(L){return"object"==typeof L}function j(L){return L&&h(L)&&Object.getPrototypeOf(L)===Object.prototype}function k(L){return{}.toString.call(L).match(/\s([a-zA-Z]+)/)[1]}function l(L,M={},N,O){for(let P in M)if(O||M.hasOwnProperty(P))if(N&&j(M[P])){const Q={};l(Q,L[P],N),l(Q,M[P],N),L[P]=Q}else L[P]=M[P]}function m(L,M,N,O=!1){H(L,M,{value:N,enumerable:O,writable:!0,configurable:!0})}function n(L,M){Object.setPrototypeOf(L,M.prototype),m(L,"constructor",M)}function q(L,M){L.prototype=Object.create(M),L.prototype.constructor=L}function r(L,M=[]){if(15<M.length||M.includes(L))return"...";if(null==L)return L+"";if("string"==typeof L)return`"${L}"`;if(c(s,L))return L.toString(M);if(M=[L].concat(M),g(L))return L.name||L.toString(M);if(c(Array,L))return`[${L.map(N=>r(N,M)).join(", ")}]`;if(L.toString!==Object.prototype.toString)return L.toString();if(L&&h(L)){const N=Object.keys(L),O="\t".repeat(M.length);return`{${N.map(P=>`\n${O+P}: ${r(L[P],M)}`).join(",")} ${N.length?`\n${O.slice(1)}`:""}}`}return L+""}function s(){const L=function(M=L.default){return L.validate(M),M};return t(L,arguments,s),L}function t(L,M,N){if(0===M.length)throw new Error("Model definition is required");n(L,N),L.definition=M[0],L.assertions=L.assertions.slice(),m(L,"errorStack",[])}function u(L){if(!j(L)){if(!c(Array,L))return[L];if(1===L.length)return[...L,void 0,null]}else for(let M of Object.keys(L))L[M]=u(L[M]);return L}function v(L,M,N,O,P,Q=!1){const R=P.indexOf(M);if(-1!==R&&-1!==P.indexOf(M,R+1))return L;if(Q&&(L=y(L,M)),c(s,M))M._validate(L,N,O,P.concat(M));else if(j(M))Object.keys(M).forEach(S=>{const T=null==L?void 0:L[S];v(T,M[S],N?N+"."+S:S,O,P)});else{const S=u(M);if(S.some(T=>w(L,T,N,P)))return L;O.push({expected:M,received:L,path:N})}return L}function w(L,M,N,O){if(null==L)return L===M;if(j(M)||c(s,M)){const P=[];return v(L,M,N,P,O),!P.length}return c(RegExp,M)?M.test(L):M===Number||M===Date?L.constructor===M&&!isNaN(L):L===M||g(M)&&c(M,L)||L.constructor===M}function x(L,M,N,O=M.errorStack){for(let P of M.assertions){let Q;try{Q=P.call(M,L)}catch(R){Q=R}if(!0!==Q){const R=g(P.description)?P.description:(S,T)=>`assertion "${P.description}" returned ${r(S)} for value ${r(T)}`;O.push({message:R.call(M,Q,L),expected:P,received:L,path:N})}}}function y(L,M=[]){if(!L||j(M)||c(s,L.constructor))return L;const N=u(M),O=[];for(let P of N)c(s,P)&&P.test(L)&&O.push(P);return 1===O.length?O[0](L):(1<O.length&&console.warn(`Ambiguous model for value ${r(L)}, could be ${O.join(" or ")}`),L)}function z(){const L=function(M=L.default){if(c(L,M))return M;if(!c(L,this))return new L(M);l(this,M,!0);const N=A(L,this,L.definition);return L.validate(N),N};return q(L,Object.prototype),t(L,arguments,z),L}function A(L,M,N,O){return j(N)?new Proxy(M||{},{get(P,Q){const R=O?O+"."+Q:Q;return A(L,P[Q],N[Q],R)},set(P,Q,R){const S=O?O+"."+Q:Q,T=L.conventionForConstant(Q),U=P[Q];if(T&&void 0!==U&&L.errorStack.push({message:`cannot redefine constant ${Q}`}),N.hasOwnProperty(Q)){const V=A(L,R,N[Q],S);v(V,N[Q],S,L.errorStack,[]),P[Q]=V,x(M,L,S)}else L.errorStack.push({message:`cannot find property ${S} in the model definition`});return L.errorStack.length&&(P[Q]=U,L.unstackErrors()),!0},has(P,Q){return Reflect.has(P,Q)&&!L.conventionForPrivate(Q)},ownKeys(P){return Reflect.ownKeys(P).filter(Q=>!L.conventionForPrivate(Q))},getPrototypeOf(){return L.prototype}}):y(M,N)}function B(){const L=function(M=L.default){return L.validate(M),new Proxy(M,{get(N,O){return"constructor"===O?L:I.includes(O)?C(N,O,L):N[O]},set(N,O,P){return D(N,O,P,L),!0},getPrototypeOf(){return L.prototype}})};return q(L,Array.prototype),t(L,arguments,B),L}function C(L,M,N){return function(){const O=L.slice();Array.prototype[M].apply(O,arguments),N.validate(O);const P=Array.prototype[M].apply(L,arguments);return L.forEach((Q,R)=>L[R]=y(Q,N.definition)),P}}function D(L,M,N,O){let P=`Array[${M}]`;parseInt(M)===+M&&0<=M&&(N=v(N,O.definition,P,O.errorStack,[],!0));const Q=L.slice();Q[M]=N,x(Q,O,P),O.unstackErrors(),L[M]=N}function E(){const L=function(N=L.default){const O=L.definition,P=function(){const Q=[];Object.assign(Q,O.defaults),Object.assign(Q,[...arguments]),Q.length>O.arguments.length&&L.errorStack.push({expected:r(N)+" to be called with "+O.arguments.length+" arguments",received:Q.length}),O.arguments.forEach((S,T)=>{Q[T]=v(Q[T],S,`arguments[${T}]`,L.errorStack,[],!0)}),x(Q,L,"arguments");let R;return L.errorStack.length||(R=N.apply(this,Q),"return"in O&&(R=v(R,O.return,"return value",L.errorStack,[],!0))),L.unstackErrors(),R};return n(P,L),P};q(L,Function.prototype);const M={arguments:[...arguments]};return t(L,[M],E),L}function F(){const L=function(M){const N=new Map(M);L.validate(N);for(let O of J)N[O]=function(){const P=new Map(N);return Map.prototype[O].apply(P,arguments),L.validate(P),Map.prototype[O].apply(N,arguments)};return n(N,L),N};return q(L,Map.prototype),t(L,arguments,F),L}function G(){const L=function(M){const N=new Set(M);L.validate(N);for(let O of K)N[O]=function(){const P=new Set(N);return Set.prototype[O].apply(P,arguments),L.validate(P),Set.prototype[O].apply(N,arguments)};return n(N,L),N};return q(L,Set.prototype),t(L,arguments,G),L}const H=Object.defineProperty;q(s,Function.prototype),Object.assign(s.prototype,{toString(L){return u(this.definition).map(M=>r(M,L)).join(" or ")},assertions:[],validate(L,M){this._validate(L,null,this.errorStack,[]),this.unstackErrors(M)},test(L){let M,N=this.errorCollector;return this.errorCollector=()=>{M=!0},this(L),this.errorCollector=N,!M},extend(){const L=[...arguments],M=L.reduce((P,Q)=>P.concat(u(Q)),u(this.definition)).filter((P,Q,R)=>R.indexOf(P)===Q);let N=[...this.assertions];L.forEach(P=>{c(s,P)&&(N=N.concat(P.assertions))});const O=new this.constructor(M);return q(O,this.prototype),O.assertions=N,O.errorCollector=this.errorCollector,O},assert(L,M=r(L)){return m(L,"description",M),this.assertions=this.assertions.concat(L),this},defaultTo(L){return this.default=L,this},errorCollector(L){let M=new TypeError(L.map(N=>N.message).join("\n"));throw M.stack=M.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),M},_validate(L,M,N,O){v(L,this.definition,M,N,O),x(L,this,M,N)},unstackErrors(L){if(this.errorStack.length){L||(L=this.errorCollector);const R=this.errorStack.map(U=>{if(!U.message){const V=c(Array,U.expected)?U.expected:[U.expected];U.message="expecting "+(U.path?U.path+" to be ":"")+V.map(W=>r(W)).join(" or ")+", got "+(null==U.received?"":k(U.received)+" ")+r(U.received)}return U});this.errorStack=[],L.call(this,R)}}}),s.prototype.conventionForConstant=L=>L.toUpperCase()===L,s.prototype.conventionForPrivate=L=>"_"===L[0],q(z,s.prototype),Object.assign(z.prototype,{defaults(L){return Object.assign(this.prototype,L),this},toString(L){return r(this.definition,L)},extend(){const L={},M={},N=[...arguments];Object.assign(L,this.definition),l(M,this.prototype,!1,!0),N.forEach(Q=>{c(s,Q)&&l(L,Q.definition,!0),g(Q)&&l(M,Q.prototype,!0,!0),h(Q)&&l(L,Q,!0,!0)});let O=[...this.assertions];N.forEach(Q=>{c(s,Q)&&(O=O.concat(Q.assertions))});const P=new this.constructor(L);return q(P,this.prototype),Object.assign(P.prototype,M),P.assertions=O,P.errorCollector=this.errorCollector,P},_validate(L,M,N,O){h(L)?v(L,this.definition,M,N,O):N.push({expected:this,received:L,path:M}),x(L,this,M,N)}});const I=["pop","push","reverse","shift","sort","splice","unshift"];q(B,s.prototype),Object.assign(B.prototype,{toString(L){return"Array of "+r(this.definition,L)},_validate(L,M,N,O){c(Array,L)?L.forEach((P,Q)=>{L[Q]=v(P,this.definition,`${M||"Array"}[${Q}]`,N,O,!0)}):N.push({expected:this,received:L,path:M}),x(L,this,M,N)}}),q(E,s.prototype),Object.assign(E.prototype,{toString(L){let M="Function("+this.definition.arguments.map(N=>r(N,L)).join(",")+")";return"return"in this.definition&&(M+=" => "+r(this.definition.return)),M},return(L){return this.definition.return=L,this},defaults(){return this.definition.defaults=[...arguments],this},_validate(L,M,N){g(L)||N.push({expected:"Function",received:L,path:M})}});const J=["set","delete","clear"];q(F,s.prototype),Object.assign(F.prototype,{toString(L){return"Map of "+r(this.definition,L)},_validate(L,M,N,O){if(L instanceof Map)for(let[P,Q]of L)v(Q,this.definition,`${M||"Map"}[${P}]`,N,O);else N.push({expected:this,received:L,path:M});x(L,this,N)}});const K=["add","delete","clear"];q(G,s.prototype),Object.assign(G.prototype,{toString(L){return"Set of "+r(this.definition,L)},_validate(L,M,N,O){if(L instanceof Set)for(let P of L.values())v(P,this.definition,M||"Set",N,O);else N.push({expected:this,received:L,path:M});x(L,this,N)}}),b.BasicModel=s,b.ObjectModel=z,b.ArrayModel=B,b.FunctionModel=E,b.MapModel=F,b.SetModel=G})(this.ObjectModelBundle=this.ObjectModelBundle||{});
