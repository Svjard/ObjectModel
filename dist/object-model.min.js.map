{"version":3,"file":"object-model.min.js","sources":["../src/helpers.js","../src/definition.js","../src/basic-model.js","../src/object-model.js","../src/model.js","../src/array-model.js","../src/function-model.js","../src/map-model.js","../src/set-model.js"],"sourcesContent":["import Model from \"./model\"\n\nexport const getProto        = Object.getPrototypeOf\nexport const is              = (Constructor, obj) => obj instanceof Constructor\nexport const isString        = s => typeof s === \"string\"\nexport const isFunction      = f => typeof f === \"function\"\nexport const isObject        = o => typeof o === \"object\"\nexport const isArray         = a => Array.isArray(a)\nexport const isPlainObject   = o => o && isObject(o) && getProto(o) === Object.prototype\nexport const isModelInstance = i => i && is(Model, getProto(i).constructor)\nexport const bettertypeof    = x => ({}).toString.call(x).match(/\\s([a-zA-Z]+)/)[1]\n\nexport const proxify      = (val, traps) => new Proxy(val, traps)\nexport const proxifyFn    = (fn, apply) => proxify(fn, {apply})\nexport const proxifyModel = (val, model, traps) => proxify(val, Object.assign({\n\tgetPrototypeOf: () => model.prototype\n}, traps))\n\nexport function merge(target, src = {}, deep, includingProto) {\n\tfor (let key in src) {\n\t\tif (includingProto || src.hasOwnProperty(key)) {\n\t\t\tif (deep && isPlainObject(src[key])) {\n\t\t\t\tconst o = {}\n\t\t\t\tmerge(o, target[key], deep)\n\t\t\t\tmerge(o, src[key], deep)\n\t\t\t\ttarget[key] = o\n\t\t\t} else {\n\t\t\t\ttarget[key] = src[key]\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function define(obj, key, value, enumerable = false) {\n\tObject.defineProperty(obj, key, {value, enumerable, writable: true, configurable: true})\n}\n\nexport function setConstructor(model, constructor) {\n\tObject.setPrototypeOf(model, constructor.prototype)\n\tdefine(model, \"constructor\", constructor)\n}\n\nexport function extend(child, parent, props) {\n\tchild.prototype = Object.assign(Object.create(parent.prototype, {\n\t\tconstructor: {\n\t\t\tvalue: child,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t}), props)\n\tObject.setPrototypeOf(child, parent)\n}\n\nexport function format(obj, stack = []) {\n\tif (stack.length > 15 || stack.includes(obj)) return '...'\n\tif (obj === null || obj === undefined) return String(obj)\n\tif (isString(obj)) return `\"${obj}\"`\n\tif (is(Model, obj)) return obj.toString(stack)\n\n\tstack.unshift(obj)\n\n\tif (isFunction(obj)) return obj.name || obj.toString(stack)\n\tif (is(Map, obj) || is(Set, obj)) return format([...obj])\n\tif (isArray(obj)) return `[${obj.map(item => format(item, stack)).join(', ')}]`\n\tif (obj.toString !== Object.prototype.toString) return obj.toString()\n\tif (obj && isObject(obj)) {\n\t\tconst props  = Object.keys(obj),\n\t\t      indent = '\\t'.repeat(stack.length)\n\t\treturn `{${props.map(\n\t\t\tkey => `\\n${indent + key}: ${format(obj[key], stack.slice())}`\n\t\t).join(',')} ${props.length ? `\\n${indent.slice(1)}` : ''}}`\n\t}\n\n\treturn String(obj)\n}\n\nexport const _constructor = \"_constructor\"\nexport const _validate = \"_validate\"","import {_validate, format, is, isArray, isFunction, isModelInstance, isPlainObject} from \"./helpers\"\nimport {Model, stackError} from \"./model\"\n\nexport function parseDefinition(def) {\n\tif (isPlainObject(def)) {\n\t\tfor (let key of Object.keys(def)) {\n\t\t\tdef[key] = parseDefinition(def[key])\n\t\t}\n\t}\n\telse if (!isArray(def)) return [def]\n\telse if (def.length === 1) return [...def, undefined, null]\n\n\treturn def\n}\n\nexport const formatDefinition = (def, stack) => parseDefinition(def).map(d => format(d, stack)).join(\" or \")\n\nexport function extendDefinition(def, newParts = []) {\n\tif (!isArray(newParts)) newParts = [newParts]\n\tif (newParts.length > 0) {\n\t\tdef = newParts\n\t\t\t.reduce((def, ext) => def.concat(ext), isArray(def) ? def.slice() : [def]) // clone to lose ref\n\t\t\t.filter((value, index, self) => self.indexOf(value) === index) // remove duplicates\n\t}\n\n\treturn def\n}\n\nexport function checkDefinition(obj, def, path, errors, stack) {\n\tconst indexFound = stack.indexOf(def)\n\tif (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)\n\t\treturn obj //if found twice in call stack, cycle detected, skip validation\n\n\tobj = cast(obj, def)\n\n\tif (is(Model, def)) {\n\t\tdef[_validate](obj, path, errors, stack.concat(def))\n\t}\n\telse if (isPlainObject(def)) {\n\t\tObject.keys(def).forEach(key => {\n\t\t\tconst val = obj != null ? obj[key] : undefined\n\t\t\tcheckDefinition(val, def[key], path ? path + '.' + key : key, errors, stack)\n\t\t})\n\t}\n\telse {\n\t\tconst pdef = parseDefinition(def)\n\t\tif (pdef.some(part => checkDefinitionPart(obj, part, path, stack)))\n\t\t\treturn obj\n\n\t\tstackError(errors, def, obj, path)\n\t}\n\n\treturn obj\n}\n\nexport function checkDefinitionPart(obj, def, path, stack) {\n\tif (obj == null) return obj === def\n\tif (isPlainObject(def) || is(Model, def)) { // object or model as part of union type\n\t\tconst errors = []\n\t\tcheckDefinition(obj, def, path, errors, stack)\n\t\treturn !errors.length\n\t}\n\tif (is(RegExp, def)) return def.test(obj)\n\tif (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)\n\treturn obj === def\n\t\t|| (isFunction(def) && is(def, obj))\n\t\t|| obj.constructor === def\n}\n\nexport function checkAssertions(obj, model, path, errors = model.errors) {\n\tfor (let assertion of model.assertions) {\n\t\tlet result\n\t\ttry {\n\t\t\tresult = assertion.call(model, obj)\n\t\t} catch (err) {\n\t\t\tresult = err\n\t\t}\n\t\tif (result !== true) {\n\t\t\tconst onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>\n\t\t\t\t`assertion \"${assertion.description}\" returned ${format(assertionResult)} `\n\t\t\t\t+`for ${path ? path+\" =\" : \"value\"} ${format(value)}`\n\t\t\tstackError(errors, assertion, obj, path, onFail.call(model, result, obj, path))\n\t\t}\n\t}\n}\n\nexport function cast(obj, defNode = []) {\n\tif (!obj || isPlainObject(defNode) || isModelInstance(obj))\n\t\treturn obj // no value or not leaf or already a model instance\n\n\tconst def = parseDefinition(defNode);\n\tconst suitableModels = []\n\n\tfor (let part of def) {\n\t\tif (is(Model, part) && part.test(obj))\n\t\t\tsuitableModels.push(part)\n\t}\n\n\tif (suitableModels.length === 1) {\n\t\t// automatically cast to suitable model when explicit\n\t\tconst model = suitableModels[0];\n\t\treturn is(Model, model) ? model(obj) : new model(obj) // basic models should not be called with new\n\t}\n\n\tif (suitableModels.length > 1)\n\t\tconsole.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(\" or \")}`)\n\n\treturn obj\n}","import {extend, is, setConstructor} from \"./helpers\"\nimport {extendDefinition} from \"./definition\"\nimport {extendModel, initModel, Model} from \"./model\"\n\n\nexport default function BasicModel(def) {\n\tconst model = function (val = model.default) {\n\t\tif (!model.validate(val)) return\n\t\treturn val\n\t}\n\n\tsetConstructor(model, BasicModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(BasicModel, Model, {\n\textend(...newParts) {\n\t\tconst child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this)\n\t\tfor (let part of newParts) {\n\t\t\tif (is(BasicModel, part)) child.assertions.push(...part.assertions)\n\t\t}\n\n\t\treturn child\n\t}\n})","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {cast, checkAssertions, checkDefinition} from \"./definition\"\nimport {\n\t_constructor,\n\t_validate,\n\textend,\n\tformat,\n\tgetProto,\n\tis,\n\tisFunction,\n\tisModelInstance,\n\tisObject,\n\tisPlainObject,\n\tisString,\n\tmerge,\n\tproxify,\n\tsetConstructor\n} from \"./helpers\"\n\nconst cannot = (model, msg) => {\n\tmodel.errors.push({message: \"cannot \" + msg})\n}\n\nexport default function ObjectModel(def) {\n\tconst model = function (obj = model.default) {\n\t\tlet instance = this\n\t\tif (!is(model, instance)) return new model(obj)\n\t\tif (is(model, obj)) return obj\n\t\tmerge(instance, model[_constructor](obj), true)\n\t\tif (!model.validate(instance)) return\n\t\treturn getProxy(model, instance, model.definition)\n\t}\n\n\textend(model, Object)\n\tsetConstructor(model, ObjectModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(ObjectModel, Model, {\n\tsealed: false,\n\n\tdefaults(p){\n\t\tObject.assign(this.prototype, p)\n\t\treturn this\n\t},\n\n\ttoString(stack){\n\t\treturn format(this.definition, stack)\n\t},\n\n\textend(...newParts){\n\t\tconst parent = this\n\t\tconst def = Object.assign({}, this.definition)\n\t\tconst newAssertions = []\n\n\t\tconst proto = {}\n\t\tmerge(proto, parent.prototype, false, true)\n\n\t\tfor (let part of newParts) {\n\t\t\tif (is(Model, part)) {\n\t\t\t\tmerge(def, part.definition, true)\n\t\t\t\tnewAssertions.push(...part.assertions)\n\t\t\t}\n\t\t\tif (isFunction(part)) merge(proto, part.prototype, true, true)\n\t\t\tif (isObject(part)) merge(def, part, true, true)\n\t\t}\n\n\t\tlet submodel = extendModel(new ObjectModel(def), parent, proto)\n\t\tsubmodel.assertions = parent.assertions.concat(newAssertions)\n\n\t\tif(getProto(parent) !== ObjectModel.prototype) { // extended class\n\t\t\tsubmodel[_constructor] = function(obj){\n\t\t\t\tlet parentInstance = new parent(obj)\n\t\t\t\tmerge(obj, parentInstance, true) // get modified props from parent class constructor\n\t\t\t\treturn obj\n\t\t\t}\n\t\t}\n\n\t\treturn submodel\n\t},\n\n\t[_validate](obj, path, errors, stack){\n\t\tif (isObject(obj)) checkDefinition(obj, this.definition, path, errors, stack)\n\t\telse stackError(errors, this, obj, path)\n\n\t\tcheckAssertions(obj, this, path, errors)\n\t}\n})\n\nfunction getProxy(model, obj, def, path) {\n\tif (!isPlainObject(def))\n\t\treturn cast(obj, def)\n\n\treturn proxify(obj || {}, {\n\t\tgetPrototypeOf: () => path ? Object.prototype : getProto(obj),\n\n\t\tget(o, key) {\n\t\t\tif (!isString(key))\n\t\t\t\treturn Reflect.get(o, key)\n\n\t\t\tconst newPath = (path ? path + '.' + key : key),\n\t\t\t      defPart = def[key];\n\n\t\t\tif (key in def && model.conventionForPrivate(key)) {\n\t\t\t\tcannot(model, `access to private property ${newPath}`)\n\t\t\t\tunstackErrors(model)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (o[key] && o.hasOwnProperty(key) && !isPlainObject(defPart) && !isModelInstance(o[key])) {\n\t\t\t\to[key] = cast(o[key], defPart) // cast nested models\n\t\t\t}\n\n\t\t\tif (isFunction(o[key]) && o[key].bind) {\n\t\t\t\treturn o[key].bind(o); // auto-bind methods to original object, so they can access private props\n\t\t\t}\n\n\t\t\treturn getProxy(model, o[key], defPart, newPath)\n\t\t},\n\n\t\tset(o, key, val) {\n\t\t\treturn controlMutation(model, def, path, o, key, (newPath) => {\n\t\t\t\tReflect.set(o, key, getProxy(model, val, def[key], newPath))\n\t\t\t})\n\t\t},\n\n\t\tdeleteProperty(o, key) {\n\t\t\treturn controlMutation(model, def, path, o, key, () => Reflect.deleteProperty(o, key))\n\t\t},\n\n\t\tdefineProperty(o, key, args){\n\t\t\treturn controlMutation(model, def, path, o, key, () => Reflect.defineProperty(o, key, args))\n\t\t},\n\n\t\thas(o, key){\n\t\t\treturn Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)\n\t\t},\n\n\t\townKeys(){\n\t\t\treturn Reflect.ownKeys(def).filter(key => !model.conventionForPrivate(key))\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(o, key){\n\t\t\tlet descriptor;\n\t\t\tif (!model.conventionForPrivate(key)) {\n\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(def, key);\n\t\t\t\tif (descriptor !== undefined) descriptor.value = o[key];\n\t\t\t}\n\n\t\t\treturn descriptor\n\t\t}\n\t})\n}\n\nfunction controlMutation(model, def, path, o, key, applyMutation) {\n\tconst newPath       = (path ? path + '.' + key : key),\n\t      isPrivate     = model.conventionForPrivate(key),\n\t      isConstant    = model.conventionForConstant(key),\n\t      isOwnProperty = o.hasOwnProperty(key)\n\n\tconst initialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key)\n\n\tif (key in def && (isPrivate || (isConstant && o[key] !== undefined)))\n\t\tcannot(model, `modify ${isPrivate ? \"private\" : \"constant\"} ${key}`)\n\n\tconst isInDefinition = def.hasOwnProperty(key);\n\tif (isInDefinition || !model.sealed) {\n\t\tapplyMutation(newPath)\n\t\tisInDefinition && checkDefinition(o[key], def[key], newPath, model.errors, [])\n\t\tcheckAssertions(o, model, newPath)\n\t}\n\telse cannot(model, `find property ${newPath} in the model definition`)\n\n\tif (model.errors.length) {\n\t\tif (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor)\n\t\telse delete o[key] // back to the initial property defined in prototype chain\n\n\t\tunstackErrors(model)\n\t\treturn false\n\t}\n\n\treturn true\n}","import {_constructor, _validate, bettertypeof, define, extend, format, isArray, isPlainObject} from \"./helpers\"\nimport {checkAssertions, checkDefinition, formatDefinition} from \"./definition\"\nimport BasicModel from \"./basic-model\"\nimport ObjectModel from \"./object-model\"\n\nexport function Model(def) {\n\treturn isPlainObject(def) ? new ObjectModel(def) : new BasicModel(def)\n}\n\nObject.assign(Model.prototype, {\n\tname: \"Model\",\n\tassertions: [],\n\n\tconventionForConstant: key => key.toUpperCase() === key,\n\tconventionForPrivate: key => key[0] === \"_\",\n\n\ttoString(stack){\n\t\treturn formatDefinition(this.definition, stack)\n\t},\n\n\tas(name){\n\t\tdefine(this, \"name\", name);\n\t\treturn this\n\t},\n\n\tdefaultTo(val){\n\t\tthis.default = val\n\t\treturn this\n\t},\n\n\t[_constructor]: o => o,\n\n\t[_validate](obj, path, errors, stack){\n\t\tcheckDefinition(obj, this.definition, path, errors, stack)\n\t\tcheckAssertions(obj, this, path, errors)\n\t},\n\n\tvalidate(obj, errorCollector){\n\t\tthis[_validate](obj, null, this.errors, [])\n\t\treturn !unstackErrors(this, errorCollector)\n\t},\n\n\ttest(obj){\n\t\tlet failed,\n\t\t    initialErrorCollector = this.errorCollector\n\n\t\tthis.errorCollector = () => {\n\t\t\tfailed = true\n\t\t}\n\n\t\tnew this(obj) // may trigger this.errorCollector\n\n\t\tthis.errorCollector = initialErrorCollector\n\t\treturn !failed\n\t},\n\n\terrorCollector(errors){\n\t\tlet e = new TypeError(errors.map(e => e.message).join('\\n'))\n\t\te.stack = e.stack.replace(/\\n.*object-model(.|\\n)*object-model.*/, \"\") // blackbox objectmodel in stacktrace\n\t\tthrow e\n\t},\n\n\tassert(assertion, description = format(assertion)){\n\t\tdefine(assertion, \"description\", description);\n\t\tthis.assertions = this.assertions.concat(assertion)\n\t\treturn this\n\t}\n})\n\nexport function initModel(model, def) {\n\tmodel.definition = def\n\tmodel.assertions = [...model.assertions]\n\tdefine(model, \"errors\", [])\n\tdelete model.name;\n}\n\nexport function extendModel(child, parent, newProps) {\n\textend(child, parent, newProps)\n\tchild.assertions.push(...parent.assertions)\n\treturn child\n}\n\nexport function stackError(errors, expected, received, path, message) {\n\terrors.push({expected, received, path, message})\n}\n\nexport function unstackErrors(model, errorCollector = model.errorCollector) {\n\tconst nbErrors = model.errors.length\n\tif (nbErrors > 0) {\n\t\tconst errors = model.errors.map(err => {\n\t\t\tif (!err.message) {\n\t\t\t\tconst def   = isArray(err.expected) ? err.expected : [err.expected]\n\t\t\t\terr.message = \"expecting \" + (err.path ? err.path + \" to be \" : \"\") + def.map(d => format(d)).join(\" or \")\n\t\t\t\t\t+ \", got \" + (err.received != null ? bettertypeof(err.received) + \" \" : \"\") + format(err.received)\n\t\t\t}\n\t\t\treturn err\n\t\t})\n\t\tmodel.errors = []\n\t\terrorCollector.call(model, errors) // throw all errors collected\n\t}\n\treturn nbErrors\n}\n\nexport default Model","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isArray, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst ARRAY_MUTATORS = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"]\n\nexport default function ArrayModel(def) {\n\n\tconst model = function (array = model.default) {\n\t\tif (!model.validate(array)) return\n\t\treturn proxifyModel(array, model, {\n\t\t\tget(arr, key) {\n\t\t\t\tlet val = arr[key];\n\t\t\t\tif (!isFunction(val)) return val\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (ARRAY_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testArray = arr.slice()\n\t\t\t\t\t\tfn.apply(testArray, args)\n\t\t\t\t\t\tmodel.validate(testArray)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst returnValue = fn.apply(arr, args)\n\t\t\t\t\tarray.forEach((a, i) => arr[i] = cast(a, model.definition))\n\t\t\t\t\treturn returnValue\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tset(arr, key, val) {\n\t\t\t\treturn setArrayKey(arr, key, val, model)\n\t\t\t},\n\n\t\t\tdeleteProperty(arr, key){\n\t\t\t\treturn !(key in arr) || setArrayKey(arr, key, undefined, model)\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Array)\n\tsetConstructor(model, ArrayModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(ArrayModel, Model, {\n\ttoString(stack){\n\t\treturn 'Array of ' + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](arr, path, errors, stack){\n\t\tif (isArray(arr))\n\t\t\tarr.forEach((a, i) => {\n\t\t\t\tarr[i] = checkDefinition(a, this.definition, `${path || \"Array\"}[${i}]`, errors, stack)\n\t\t\t})\n\t\telse stackError(errors, this, arr, path)\n\n\t\tcheckAssertions(arr, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})\n\nfunction setArrayKey(array, key, value, model) {\n\tlet path = `Array[${key}]`;\n\tif (parseInt(key) === +key && key >= 0)\n\t\tvalue = checkDefinition(value, model.definition, path, model.errors, [])\n\n\tconst testArray = array.slice()\n\ttestArray[key] = value\n\tcheckAssertions(testArray, model, path)\n\tconst isSuccess = !unstackErrors(model)\n\tif (isSuccess) array[key] = value\n\treturn isSuccess\n}","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyModel, setConstructor} from \"./helpers\"\n\n\nexport default function FunctionModel(...argsDef) {\n\n\tconst model = function (fn = model.default) {\n\t\tif (!model.validate(fn)) return\n\t\treturn proxifyModel(fn, model, {\n\t\t\tapply (fn, ctx, args) {\n\t\t\t\tconst def = model.definition\n\n\t\t\t\tdef.arguments.forEach((argDef, i) => {\n\t\t\t\t\targs[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [])\n\t\t\t\t})\n\n\t\t\t\tcheckAssertions(args, model, \"arguments\")\n\n\t\t\t\tlet result\n\t\t\t\tif (!model.errors.length) {\n\t\t\t\t\tresult = Reflect.apply(fn, ctx, args)\n\t\t\t\t\tif (\"return\" in def)\n\t\t\t\t\t\tresult = checkDefinition(result, def.return, \"return value\", model.errors, [])\n\t\t\t\t}\n\t\t\t\tunstackErrors(model)\n\t\t\t\treturn result\n\t\t\t}\n\t\t});\n\t}\n\n\textend(model, Function)\n\tsetConstructor(model, FunctionModel)\n\tinitModel(model, {arguments: argsDef})\n\n\treturn model\n}\n\nextend(FunctionModel, Model, {\n\ttoString(stack = []){\n\t\tlet out = `Function(${this.definition.arguments.map(\n\t\t\targDef => formatDefinition(argDef, stack.slice())\n\t\t).join(\",\")})`\n\n\t\tif (\"return\" in this.definition) {\n\t\t\tout += \" => \" + formatDefinition(this.definition.return, stack)\n\t\t}\n\t\treturn out\n\t},\n\n\treturn(def){\n\t\tthis.definition.return = def\n\t\treturn this\n\t},\n\n\textend(newArgs, newReturns) {\n\t\tconst args = this.definition.arguments\n\t\tconst mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i]))\n\t\tconst mixedReturns = extendDefinition(this.definition.return, newReturns)\n\t\treturn extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)\n\t},\n\n\t[_validate](f, path, errors){\n\t\tif (!isFunction(f)) {\n\t\t\tstackError(errors, \"Function\", f, path)\n\t\t}\n\t}\n})\n\nFunctionModel.prototype.assert(function (args) {\n\tif (args.length > this.definition.arguments.length) return args\n\treturn true\n}, function (args) {\n\treturn `expecting ${this.definition.arguments.length} arguments for ${format(this)}, got ${args.length}`\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst MAP_MUTATORS = [\"set\", \"delete\", \"clear\"]\n\nexport default function MapModel(key, value) {\n\n\tconst model = function (iterable = model.default) {\n\t\tconst castKeyValue = pair => [\"key\", \"value\"].map((prop, i) => cast(pair[i], model.definition[prop]))\n\t\tconst map          = new Map([...iterable].map(castKeyValue))\n\n\t\tif (!model.validate(map)) return\n\n\t\treturn proxifyModel(map, model, {\n\t\t\tget(map, key) {\n\t\t\t\tlet val = map[key];\n\t\t\t\tif (!isFunction(val)) return val\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"set\") {\n\t\t\t\t\t\targs = castKeyValue(args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (MAP_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testMap = new Map(map)\n\t\t\t\t\t\tfn.apply(testMap, args)\n\t\t\t\t\t\tmodel.validate(testMap)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(map, args)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Map)\n\tsetConstructor(model, MapModel)\n\tinitModel(model, {key, value})\n\treturn model\n}\n\nextend(MapModel, Model, {\n\ttoString(stack) {\n\t\tconst {key, value} = this.definition\n\t\treturn `Map of ${formatDefinition(key, stack)} : ${formatDefinition(value, stack)}`\n\t},\n\n\t[_validate](map, path, errors, stack) {\n\t\tif (map instanceof Map) {\n\t\t\tpath = path || 'Map'\n\t\t\tfor (let [key, value] of map) {\n\t\t\t\tcheckDefinition(key, this.definition.key, `${path} key`, errors, stack)\n\t\t\t\tcheckDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, map, path)\n\n\t\tcheckAssertions(map, this, path, errors)\n\t},\n\n\textend(newKeys, newValues){\n\t\tconst {key, value} = this.definition\n\t\treturn extendModel(new MapModel(extendDefinition(key, newKeys), extendDefinition(value, newValues)), this)\n\t}\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst SET_MUTATORS = [\"add\", \"delete\", \"clear\"]\n\nexport default function SetModel(def) {\n\n\tconst model = function (iterable = model.default) {\n\t\tconst castValue = val => cast(val, model.definition)\n\t\tconst set       = new Set([...iterable].map(castValue))\n\n\t\tif (!model.validate(set)) return\n\n\t\treturn proxifyModel(set, model, {\n\t\t\tget(set, key) {\n\t\t\t\tlet val = set[key]\n\t\t\t\tif (!isFunction(val)) return val;\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"add\") {\n\t\t\t\t\t\targs[0] = castValue(args[0])\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SET_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testSet = new Set(set)\n\t\t\t\t\t\tfn.apply(testSet, args)\n\t\t\t\t\t\tmodel.validate(testSet)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(set, args)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Set)\n\tsetConstructor(model, SetModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(SetModel, Model, {\n\ttoString(stack){\n\t\treturn \"Set of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](set, path, errors, stack){\n\t\tif (set instanceof Set) {\n\t\t\tfor (let item of set.values()) {\n\t\t\t\tcheckDefinition(item, this.definition, `${path || \"Set\"} value`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, set, path)\n\t\tcheckAssertions(set, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})"],"names":["merge","target","src","deep","includingProto","key","hasOwnProperty","isPlainObject","o","define","obj","value","enumerable","Object","defineProperty","writable","configurable","setConstructor","model","constructor","setPrototypeOf","prototype","extend","child","parent","props","assign","create","format","stack","length","includes","undefined","String","isString","is","Model","toString","unshift","isFunction","name","Map","Set","isArray","map","item","join","isObject","keys","indent","repeat","slice","def","parseDefinition","extendDefinition","newParts","reduce","ext","concat","filter","index","self","indexOf","checkDefinition","path","errors","indexFound","cast","_validate","forEach","val","pdef","some","part","checkDefinitionPart","stackError","RegExp","test","Number","Date","isNaN","checkAssertions","assertion","assertions","result","call","err","onFail","description","assertionResult","defNode","isModelInstance","suitableModels","push","console","warn","BasicModel","default","validate","initModel","ObjectModel","instance","this","_constructor","getProxy","definition","proxify","getPrototypeOf","getProto","[object Object]","Reflect","get","newPath","defPart","conventionForPrivate","cannot","unstackErrors","bind","controlMutation","set","deleteProperty","args","has","ownKeys","descriptor","getOwnPropertyDescriptor","applyMutation","isPrivate","isConstant","conventionForConstant","isOwnProperty","initialPropDescriptor","isInDefinition","sealed","extendModel","newProps","expected","received","message","errorCollector","nbErrors","d","bettertypeof","ArrayModel","array","proxifyModel","arr","proxifyFn","fn","ctx","ARRAY_MUTATORS","testArray","apply","returnValue","a","i","setArrayKey","Array","parseInt","isSuccess","FunctionModel","argsDef","arguments","argDef","return","Function","MapModel","iterable","castKeyValue","pair","prop","MAP_MUTATORS","testMap","SetModel","castValue","SET_MUTATORS","testSet","Constructor","s","f","x","match","traps","Proxy","formatDefinition","msg","p","newAssertions","proto","submodel","toUpperCase","failed","initialErrorCollector","e","TypeError","replace","out","newArgs","newReturns","mixedArgs","mixedReturns","assert","newKeys","newValues","values"],"mappings":"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"}