{"version":3,"file":"object-model.min.js","sources":["../src/helpers.js","../src/definition.js","../src/basic-model.js","../src/object-model.js","../src/model.js","../src/array-model.js","../src/function-model.js","../src/map-model.js","../src/set-model.js"],"sourcesContent":["import Model from \"./model\"\n\nexport const getProto        = Object.getPrototypeOf\nexport const is              = (Constructor, obj) => obj instanceof Constructor\nexport const isString        = s => typeof s === \"string\"\nexport const isFunction      = f => typeof f === \"function\"\nexport const isObject        = o => typeof o === \"object\"\nexport const isArray         = a => Array.isArray(a)\nexport const isPlainObject   = o => o && isObject(o) && getProto(o) === Object.prototype\nexport const isModelInstance = i => i && is(Model, getProto(i).constructor)\nexport const bettertypeof    = x => ({}).toString.call(x).match(/\\s([a-zA-Z]+)/)[1]\n\nexport const proxify      = (val, traps) => new Proxy(val, traps)\nexport const proxifyFn    = (fn, apply) => proxify(fn, {apply})\nexport const proxifyModel = (val, model, traps) => proxify(val, Object.assign({\n\tgetPrototypeOf: () => model.prototype\n}, traps))\n\nexport function merge(target, src = {}, deep, includingProto) {\n\tfor (let key in src) {\n\t\tif (includingProto || src.hasOwnProperty(key)) {\n\t\t\tif (deep && isPlainObject(src[key])) {\n\t\t\t\tconst o = {}\n\t\t\t\tmerge(o, target[key], deep)\n\t\t\t\tmerge(o, src[key], deep)\n\t\t\t\ttarget[key] = o\n\t\t\t} else {\n\t\t\t\ttarget[key] = src[key]\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function define(obj, key, value, enumerable = false) {\n\tObject.defineProperty(obj, key, {value, enumerable, writable: true, configurable: true})\n}\n\nexport function setConstructor(model, constructor) {\n\tObject.setPrototypeOf(model, constructor.prototype)\n\tdefine(model, \"constructor\", constructor)\n}\n\nexport function extend(child, parent, props) {\n\tchild.prototype = Object.assign(Object.create(parent.prototype, {\n\t\tconstructor: {\n\t\t\tvalue: child,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t}), props)\n\tObject.setPrototypeOf(child, parent)\n}\n\nexport function format(obj, stack = []) {\n\tif (stack.length > 15 || stack.includes(obj)) return '...'\n\tif (obj === null || obj === undefined) return String(obj)\n\tif (isString(obj)) return `\"${obj}\"`\n\tif (is(Model, obj)) return obj.toString(stack)\n\n\tstack.unshift(obj)\n\n\tif (isFunction(obj)) return obj.name || obj.toString(stack)\n\tif (is(Map, obj) || is(Set, obj)) return format([...obj])\n\tif (isArray(obj)) return `[${obj.map(item => format(item, stack)).join(', ')}]`\n\tif (obj.toString !== Object.prototype.toString) return obj.toString()\n\tif (obj && isObject(obj)) {\n\t\tconst props  = Object.keys(obj),\n\t\t      indent = '\\t'.repeat(stack.length)\n\t\treturn `{${props.map(\n\t\t\tkey => `\\n${indent + key}: ${format(obj[key], stack.slice())}`\n\t\t).join(',')} ${props.length ? `\\n${indent.slice(1)}` : ''}}`\n\t}\n\n\treturn String(obj)\n}\n\nexport const _constructor = \"_constructor\"\nexport const _validate = \"_validate\"","import {_validate, format, is, isArray, isFunction, isModelInstance, isPlainObject} from \"./helpers\"\nimport {Model, stackError} from \"./model\"\n\nexport function parseDefinition(def) {\n\tif (isPlainObject(def)) {\n\t\tfor (let key of Object.keys(def)) {\n\t\t\tdef[key] = parseDefinition(def[key])\n\t\t}\n\t}\n\telse if (!isArray(def)) return [def]\n\telse if (def.length === 1) return [...def, undefined, null]\n\n\treturn def\n}\n\nexport const formatDefinition = (def, stack) => parseDefinition(def).map(d => format(d, stack)).join(\" or \")\n\nexport function extendDefinition(def, newParts = []) {\n\tif (!isArray(newParts)) newParts = [newParts]\n\tif (newParts.length > 0) {\n\t\tdef = newParts\n\t\t\t.reduce((def, ext) => def.concat(ext), isArray(def) ? def.slice() : [def]) // clone to lose ref\n\t\t\t.filter((value, index, self) => self.indexOf(value) === index) // remove duplicates\n\t}\n\n\treturn def\n}\n\nexport function checkDefinition(obj, def, path, errors, stack, shouldCast = false) {\n\tconst indexFound = stack.indexOf(def)\n\tif (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)\n\t\treturn obj //if found twice in call stack, cycle detected, skip validation\n\n\tif (shouldCast)\n\t\tobj = cast(obj, def)\n\n\tif (is(Model, def)) {\n\t\tdef[_validate](obj, path, errors, stack.concat(def))\n\t}\n\telse if (isPlainObject(def)) {\n\t\tObject.keys(def).forEach(key => {\n\t\t\tconst val = obj != null ? obj[key] : undefined\n\t\t\tcheckDefinition(val, def[key], path ? path + '.' + key : key, errors, stack)\n\t\t})\n\t}\n\telse {\n\t\tconst pdef = parseDefinition(def)\n\t\tif (pdef.some(part => checkDefinitionPart(obj, part, path, stack)))\n\t\t\treturn obj\n\n\t\tstackError(errors, def, obj, path)\n\t}\n\n\treturn obj\n}\n\nexport function checkDefinitionPart(obj, def, path, stack) {\n\tif (obj == null) return obj === def\n\tif (isPlainObject(def) || is(Model, def)) { // object or model as part of union type\n\t\tconst errors = []\n\t\tcheckDefinition(obj, def, path, errors, stack)\n\t\treturn !errors.length\n\t}\n\tif (is(RegExp, def)) return def.test(obj)\n\tif (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)\n\treturn obj === def\n\t\t|| (isFunction(def) && is(def, obj))\n\t\t|| obj.constructor === def\n}\n\nexport function checkAssertions(obj, model, path, errors = model.errors) {\n\tfor (let assertion of model.assertions) {\n\t\tlet result\n\t\ttry {\n\t\t\tresult = assertion.call(model, obj)\n\t\t} catch (err) {\n\t\t\tresult = err\n\t\t}\n\t\tif (result !== true) {\n\t\t\tconst onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>\n\t\t\t\t`assertion \"${assertion.description}\" returned ${format(assertionResult)} `\n\t\t\t\t+`for ${path ? path+\" =\" : \"value\"} ${format(value)}`\n\t\t\tstackError(errors, assertion, obj, path, onFail.call(model, result, obj, path))\n\t\t}\n\t}\n}\n\nexport function cast(obj, defNode = []) {\n\tif (!obj || isPlainObject(defNode) || isModelInstance(obj))\n\t\treturn obj // no value or not leaf or already a model instance\n\n\tconst def = parseDefinition(defNode);\n\tconst suitableModels = []\n\n\tfor (let part of def) {\n\t\tif (is(Model, part) && part.test(obj))\n\t\t\tsuitableModels.push(part)\n\t}\n\n\tif (suitableModels.length === 1) {\n\t\t// automatically cast to suitable model when explicit\n\t\tconst model = suitableModels[0];\n\t\treturn is(Model, model) ? model(obj) : new model(obj) // basic models should not be called with new\n\t}\n\n\tif (suitableModels.length > 1)\n\t\tconsole.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(\" or \")}`)\n\n\treturn obj\n}","import {extend, is, setConstructor} from \"./helpers\"\nimport {extendDefinition} from \"./definition\"\nimport {extendModel, initModel, Model} from \"./model\"\n\n\nexport default function BasicModel(def) {\n\tconst model = function (val = model.default) {\n\t\tif (!model.validate(val)) return\n\t\treturn val\n\t}\n\n\tsetConstructor(model, BasicModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(BasicModel, Model, {\n\textend(...newParts) {\n\t\tconst child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this)\n\t\tfor (let part of newParts) {\n\t\t\tif (is(BasicModel, part)) child.assertions.push(...part.assertions)\n\t\t}\n\n\t\treturn child\n\t}\n})","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {cast, checkAssertions, checkDefinition} from \"./definition\"\nimport {\n\t_constructor,\n\t_validate,\n\textend,\n\tformat,\n\tgetProto,\n\tis,\n\tisFunction,\n\tisModelInstance,\n\tisObject,\n\tisPlainObject,\n\tisString,\n\tmerge,\n\tproxify,\n\tsetConstructor\n} from \"./helpers\"\n\nconst cannot = (model, msg) => {\n\tmodel.errors.push({message: \"cannot \" + msg})\n}\n\nexport default function ObjectModel(def) {\n\tconst model = function (obj = model.default) {\n\t\tlet instance = this\n\t\tif (!is(model, instance)) return new model(obj)\n\t\tif (is(model, obj)) return obj\n\t\tmerge(instance, model[_constructor](obj), true)\n\t\tif (!model.validate(instance)) return\n\t\treturn getProxy(model, instance, model.definition)\n\t}\n\n\textend(model, Object)\n\tsetConstructor(model, ObjectModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(ObjectModel, Model, {\n\tsealed: false,\n\n\tdefaults(p){\n\t\tObject.assign(this.prototype, p)\n\t\treturn this\n\t},\n\n\ttoString(stack){\n\t\treturn format(this.definition, stack)\n\t},\n\n\textend(...newParts){\n\t\tconst parent = this\n\t\tconst def = Object.assign({}, this.definition)\n\t\tconst newAssertions = []\n\n\t\tconst proto = {}\n\t\tmerge(proto, parent.prototype, false, true)\n\n\t\tfor (let part of newParts) {\n\t\t\tif (is(Model, part)) {\n\t\t\t\tmerge(def, part.definition, true)\n\t\t\t\tnewAssertions.push(...part.assertions)\n\t\t\t}\n\t\t\tif (isFunction(part)) merge(proto, part.prototype, true, true)\n\t\t\tif (isObject(part)) merge(def, part, true, true)\n\t\t}\n\n\t\tlet submodel = extendModel(new ObjectModel(def), parent, proto)\n\t\tsubmodel.assertions = parent.assertions.concat(newAssertions)\n\n\t\tif(getProto(parent) !== ObjectModel.prototype) { // extended class\n\t\t\tsubmodel[_constructor] = function(obj){\n\t\t\t\tlet parentInstance = new parent(obj)\n\t\t\t\tmerge(obj, parentInstance, true) // get modified props from parent class constructor\n\t\t\t\treturn obj\n\t\t\t}\n\t\t}\n\n\t\treturn submodel\n\t},\n\n\t[_validate](obj, path, errors, stack){\n\t\tif (isObject(obj)) checkDefinition(obj, this.definition, path, errors, stack)\n\t\telse stackError(errors, this, obj, path)\n\n\t\tcheckAssertions(obj, this, path, errors)\n\t}\n})\n\nfunction getProxy(model, obj, def, path) {\n\tif (!isPlainObject(def))\n\t\treturn cast(obj, def)\n\n\treturn proxify(obj || {}, {\n\t\tgetPrototypeOf: () => path ? Object.prototype : getProto(obj),\n\n\t\tget(o, key) {\n\t\t\tif (!isString(key))\n\t\t\t\treturn Reflect.get(o, key)\n\n\t\t\tconst newPath = (path ? path + '.' + key : key),\n\t\t\t      defPart = def[key];\n\n\t\t\tif (key in def && model.conventionForPrivate(key)) {\n\t\t\t\tcannot(model, `access to private property ${newPath}`)\n\t\t\t\tunstackErrors(model)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (o[key] && o.hasOwnProperty(key) && !isPlainObject(defPart) && !isModelInstance(o[key])) {\n\t\t\t\to[key] = cast(o[key], defPart) // cast nested models\n\t\t\t}\n\n\t\t\tif (isFunction(o[key]) && o[key].bind) {\n\t\t\t\treturn o[key].bind(o); // auto-bind methods to original object, so they can access private props\n\t\t\t}\n\n\t\t\treturn getProxy(model, o[key], defPart, newPath)\n\t\t},\n\n\t\tset(o, key, val) {\n\t\t\treturn controlMutation(model, def, path, o, key, (newPath) => {\n\t\t\t\tReflect.set(o, key, getProxy(model, val, def[key], newPath))\n\t\t\t})\n\t\t},\n\n\t\tdeleteProperty(o, key) {\n\t\t\treturn controlMutation(model, def, path, o, key, () => Reflect.deleteProperty(o, key))\n\t\t},\n\n\t\tdefineProperty(o, key, args){\n\t\t\treturn controlMutation(model, def, path, o, key, () => Reflect.defineProperty(o, key, args))\n\t\t},\n\n\t\thas(o, key){\n\t\t\treturn Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)\n\t\t},\n\n\t\townKeys(){\n\t\t\treturn Reflect.ownKeys(def).filter(key => !model.conventionForPrivate(key))\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(o, key){\n\t\t\tlet descriptor;\n\t\t\tif (!model.conventionForPrivate(key)) {\n\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(def, key);\n\t\t\t\tif (descriptor !== undefined) descriptor.value = o[key];\n\t\t\t}\n\n\t\t\treturn descriptor\n\t\t}\n\t})\n}\n\nfunction controlMutation(model, def, path, o, key, applyMutation) {\n\tconst newPath       = (path ? path + '.' + key : key),\n\t      isPrivate     = model.conventionForPrivate(key),\n\t      isConstant    = model.conventionForConstant(key),\n\t      isOwnProperty = o.hasOwnProperty(key)\n\n\tconst initialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key)\n\n\tif (key in def && (isPrivate || (isConstant && o[key] !== undefined)))\n\t\tcannot(model, `modify ${isPrivate ? \"private\" : \"constant\"} ${key}`)\n\n\tconst isInDefinition = def.hasOwnProperty(key);\n\tif (isInDefinition || !model.sealed) {\n\t\tapplyMutation(newPath)\n\t\tisInDefinition && checkDefinition(o[key], def[key], newPath, model.errors, [])\n\t\tcheckAssertions(o, model, newPath)\n\t}\n\telse cannot(model, `find property ${newPath} in the model definition`)\n\n\tif (model.errors.length) {\n\t\tif (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor)\n\t\telse delete o[key] // back to the initial property defined in prototype chain\n\n\t\tunstackErrors(model)\n\t\treturn false\n\t}\n\n\treturn true\n}","import {_constructor, _validate, bettertypeof, define, extend, format, isArray, isPlainObject} from \"./helpers\"\nimport {checkAssertions, checkDefinition, formatDefinition} from \"./definition\"\nimport BasicModel from \"./basic-model\"\nimport ObjectModel from \"./object-model\"\n\nexport function Model(def) {\n\treturn isPlainObject(def) ? new ObjectModel(def) : new BasicModel(def)\n}\n\nObject.assign(Model.prototype, {\n\tname: \"Model\",\n\tassertions: [],\n\n\tconventionForConstant: key => key.toUpperCase() === key,\n\tconventionForPrivate: key => key[0] === \"_\",\n\n\ttoString(stack){\n\t\treturn formatDefinition(this.definition, stack)\n\t},\n\n\tas(name){\n\t\tdefine(this, \"name\", name);\n\t\treturn this\n\t},\n\n\tdefaultTo(val){\n\t\tthis.default = val\n\t\treturn this\n\t},\n\n\t[_constructor]: o => o,\n\n\t[_validate](obj, path, errors, stack){\n\t\tcheckDefinition(obj, this.definition, path, errors, stack)\n\t\tcheckAssertions(obj, this, path, errors)\n\t},\n\n\tvalidate(obj, errorCollector){\n\t\tthis[_validate](obj, null, this.errors, [])\n\t\treturn !unstackErrors(this, errorCollector)\n\t},\n\n\ttest(obj){\n\t\tlet failed,\n\t\t    initialErrorCollector = this.errorCollector\n\n\t\tthis.errorCollector = () => {\n\t\t\tfailed = true\n\t\t}\n\n\t\tnew this(obj) // may trigger this.errorCollector\n\n\t\tthis.errorCollector = initialErrorCollector\n\t\treturn !failed\n\t},\n\n\terrorCollector(errors){\n\t\tlet e = new TypeError(errors.map(e => e.message).join('\\n'))\n\t\te.stack = e.stack.replace(/\\n.*object-model(.|\\n)*object-model.*/, \"\") // blackbox objectmodel in stacktrace\n\t\tthrow e\n\t},\n\n\tassert(assertion, description = format(assertion)){\n\t\tdefine(assertion, \"description\", description);\n\t\tthis.assertions = this.assertions.concat(assertion)\n\t\treturn this\n\t}\n})\n\nexport function initModel(model, def) {\n\tmodel.definition = def\n\tmodel.assertions = [...model.assertions]\n\tdefine(model, \"errors\", [])\n\tdelete model.name;\n}\n\nexport function extendModel(child, parent, newProps) {\n\textend(child, parent, newProps)\n\tchild.assertions.push(...parent.assertions)\n\treturn child\n}\n\nexport function stackError(errors, expected, received, path, message) {\n\terrors.push({expected, received, path, message})\n}\n\nexport function unstackErrors(model, errorCollector = model.errorCollector) {\n\tconst nbErrors = model.errors.length\n\tif (nbErrors > 0) {\n\t\tconst errors = model.errors.map(err => {\n\t\t\tif (!err.message) {\n\t\t\t\tconst def   = isArray(err.expected) ? err.expected : [err.expected]\n\t\t\t\terr.message = \"expecting \" + (err.path ? err.path + \" to be \" : \"\") + def.map(d => format(d)).join(\" or \")\n\t\t\t\t\t+ \", got \" + (err.received != null ? bettertypeof(err.received) + \" \" : \"\") + format(err.received)\n\t\t\t}\n\t\t\treturn err\n\t\t})\n\t\tmodel.errors = []\n\t\terrorCollector.call(model, errors) // throw all errors collected\n\t}\n\treturn nbErrors\n}\n\nexport default Model","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isArray, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst ARRAY_MUTATORS = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"]\n\nexport default function ArrayModel(def) {\n\n\tconst model = function (array = model.default) {\n\t\tif (!model.validate(array)) return\n\t\treturn proxifyModel(array, model, {\n\t\t\tget(arr, key) {\n\t\t\t\tlet val = arr[key];\n\t\t\t\tif (!isFunction(val)) return val\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (ARRAY_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testArray = arr.slice()\n\t\t\t\t\t\tfn.apply(testArray, args)\n\t\t\t\t\t\tmodel.validate(testArray)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst returnValue = fn.apply(arr, args)\n\t\t\t\t\tarray.forEach((a, i) => arr[i] = cast(a, model.definition))\n\t\t\t\t\treturn returnValue\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tset(arr, key, val) {\n\t\t\t\treturn setArrayKey(arr, key, val, model)\n\t\t\t},\n\n\t\t\tdeleteProperty(arr, key){\n\t\t\t\treturn !(key in arr) || setArrayKey(arr, key, undefined, model)\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Array)\n\tsetConstructor(model, ArrayModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(ArrayModel, Model, {\n\ttoString(stack){\n\t\treturn 'Array of ' + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](arr, path, errors, stack){\n\t\tif (isArray(arr))\n\t\t\tarr.forEach((a, i) => {\n\t\t\t\tarr[i] = checkDefinition(a, this.definition, `${path || \"Array\"}[${i}]`, errors, stack, true)\n\t\t\t})\n\t\telse stackError(errors, this, arr, path)\n\n\t\tcheckAssertions(arr, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})\n\nfunction setArrayKey(array, key, value, model) {\n\tlet path = `Array[${key}]`;\n\tif (parseInt(key) === +key && key >= 0)\n\t\tvalue = checkDefinition(value, model.definition, path, model.errors, [], true)\n\n\tconst testArray = array.slice()\n\ttestArray[key] = value\n\tcheckAssertions(testArray, model, path)\n\tconst isSuccess = !unstackErrors(model)\n\tif (isSuccess) array[key] = value\n\treturn isSuccess\n}","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyModel, setConstructor} from \"./helpers\"\n\n\nexport default function FunctionModel(...argsDef) {\n\n\tconst model = function (fn = model.default) {\n\t\tif (!model.validate(fn)) return\n\t\treturn proxifyModel(fn, model, {\n\t\t\tapply (fn, ctx, args) {\n\t\t\t\tconst def = model.definition\n\n\t\t\t\tdef.arguments.forEach((argDef, i) => {\n\t\t\t\t\targs[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [], true)\n\t\t\t\t})\n\n\t\t\t\tcheckAssertions(args, model, \"arguments\")\n\n\t\t\t\tlet result\n\t\t\t\tif (!model.errors.length) {\n\t\t\t\t\tresult = Reflect.apply(fn, ctx, args)\n\t\t\t\t\tif (\"return\" in def)\n\t\t\t\t\t\tresult = checkDefinition(result, def.return, \"return value\", model.errors, [], true)\n\t\t\t\t}\n\t\t\t\tunstackErrors(model)\n\t\t\t\treturn result\n\t\t\t}\n\t\t});\n\t}\n\n\textend(model, Function)\n\tsetConstructor(model, FunctionModel)\n\tinitModel(model, {arguments: argsDef})\n\n\treturn model\n}\n\nextend(FunctionModel, Model, {\n\ttoString(stack = []){\n\t\tlet out = `Function(${this.definition.arguments.map(\n\t\t\targDef => formatDefinition(argDef, stack.slice())\n\t\t).join(\",\")})`\n\n\t\tif (\"return\" in this.definition) {\n\t\t\tout += \" => \" + formatDefinition(this.definition.return, stack)\n\t\t}\n\t\treturn out\n\t},\n\n\treturn(def){\n\t\tthis.definition.return = def\n\t\treturn this\n\t},\n\n\textend(newArgs, newReturns) {\n\t\tconst args = this.definition.arguments\n\t\tconst mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i]))\n\t\tconst mixedReturns = extendDefinition(this.definition.return, newReturns)\n\t\treturn extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)\n\t},\n\n\t[_validate](f, path, errors){\n\t\tif (!isFunction(f)) {\n\t\t\tstackError(errors, \"Function\", f, path)\n\t\t}\n\t}\n})\n\nFunctionModel.prototype.assert(function (args) {\n\tif (args.length > this.definition.arguments.length) return args\n\treturn true\n}, function (args) {\n\treturn `expecting ${this.definition.arguments.length} arguments for ${format(this)}, got ${args.length}`\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst MAP_MUTATORS = [\"set\", \"delete\", \"clear\"]\n\nexport default function MapModel(key, value) {\n\n\tconst model = function (iterable = model.default) {\n\t\tconst castKeyValue = pair => [\"key\", \"value\"].map((prop, i) => cast(pair[i], model.definition[prop]))\n\t\tconst map          = new Map([...iterable].map(castKeyValue))\n\n\t\tif (!model.validate(map)) return\n\n\t\treturn proxifyModel(map, model, {\n\t\t\tget(map, key) {\n\t\t\t\tlet val = map[key];\n\t\t\t\tif (!isFunction(val)) return val\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"set\") {\n\t\t\t\t\t\targs = castKeyValue(args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (MAP_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testMap = new Map(map)\n\t\t\t\t\t\tfn.apply(testMap, args)\n\t\t\t\t\t\tmodel.validate(testMap)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(map, args)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Map)\n\tsetConstructor(model, MapModel)\n\tinitModel(model, {key, value})\n\treturn model\n}\n\nextend(MapModel, Model, {\n\ttoString(stack) {\n\t\tconst {key, value} = this.definition\n\t\treturn `Map of ${formatDefinition(key, stack)} : ${formatDefinition(value, stack)}`\n\t},\n\n\t[_validate](map, path, errors, stack) {\n\t\tif (map instanceof Map) {\n\t\t\tpath = path || 'Map'\n\t\t\tfor (let [key, value] of map) {\n\t\t\t\tcheckDefinition(key, this.definition.key, `${path} key`, errors, stack)\n\t\t\t\tcheckDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, map, path)\n\n\t\tcheckAssertions(map, this, path, errors)\n\t},\n\n\textend(newKeys, newValues){\n\t\tconst {key, value} = this.definition\n\t\treturn extendModel(new MapModel(extendDefinition(key, newKeys), extendDefinition(value, newValues)), this)\n\t}\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nconst SET_MUTATORS = [\"add\", \"delete\", \"clear\"]\n\nexport default function SetModel(def) {\n\n\tconst model = function (iterable = model.default) {\n\t\tconst castValue = val => cast(val, model.definition)\n\t\tconst set       = new Set([...iterable].map(castValue))\n\n\t\tif (!model.validate(set)) return\n\n\t\treturn proxifyModel(set, model, {\n\t\t\tget(set, key) {\n\t\t\t\tlet val = set[key]\n\t\t\t\tif (!isFunction(val)) return val;\n\n\t\t\t\treturn proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"add\") {\n\t\t\t\t\t\targs[0] = castValue(args[0])\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SET_MUTATORS.includes(key)) {\n\t\t\t\t\t\tconst testSet = new Set(set)\n\t\t\t\t\t\tfn.apply(testSet, args)\n\t\t\t\t\t\tmodel.validate(testSet)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(set, args)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Set)\n\tsetConstructor(model, SetModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(SetModel, Model, {\n\ttoString(stack){\n\t\treturn \"Set of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](set, path, errors, stack){\n\t\tif (set instanceof Set) {\n\t\t\tfor (let item of set.values()) {\n\t\t\t\tcheckDefinition(item, this.definition, `${path || \"Set\"} value`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, set, path)\n\t\tcheckAssertions(set, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})"],"names":["merge","target","src","deep","includingProto","key","hasOwnProperty","isPlainObject","o","define","obj","value","enumerable","Object","defineProperty","writable","configurable","setConstructor","model","constructor","setPrototypeOf","prototype","extend","child","parent","props","assign","create","format","stack","length","includes","undefined","String","isString","is","Model","toString","unshift","isFunction","name","Map","Set","isArray","map","item","join","isObject","keys","indent","repeat","slice","def","parseDefinition","extendDefinition","newParts","reduce","ext","concat","filter","index","self","indexOf","checkDefinition","path","errors","shouldCast","indexFound","cast","_validate","forEach","val","pdef","some","part","checkDefinitionPart","stackError","RegExp","test","Number","Date","isNaN","checkAssertions","assertion","assertions","result","call","err","onFail","description","assertionResult","defNode","isModelInstance","suitableModels","push","console","warn","BasicModel","default","validate","initModel","ObjectModel","instance","this","_constructor","getProxy","definition","proxify","getPrototypeOf","getProto","[object Object]","Reflect","get","newPath","defPart","conventionForPrivate","cannot","unstackErrors","bind","controlMutation","set","deleteProperty","args","has","ownKeys","descriptor","getOwnPropertyDescriptor","applyMutation","isPrivate","isConstant","conventionForConstant","isOwnProperty","initialPropDescriptor","isInDefinition","sealed","extendModel","newProps","expected","received","message","errorCollector","nbErrors","d","bettertypeof","ArrayModel","array","proxifyModel","arr","proxifyFn","fn","ctx","ARRAY_MUTATORS","testArray","apply","returnValue","a","i","setArrayKey","Array","parseInt","isSuccess","FunctionModel","argsDef","arguments","argDef","return","Function","MapModel","iterable","castKeyValue","pair","prop","MAP_MUTATORS","testMap","SetModel","castValue","SET_MUTATORS","testSet","Constructor","s","f","x","match","traps","Proxy","formatDefinition","msg","p","newAssertions","proto","submodel","toUpperCase","failed","initialErrorCollector","e","TypeError","replace","out","newArgs","newReturns","mixedArgs","mixedReturns","assert","newKeys","newValues","values"],"mappings":"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"}